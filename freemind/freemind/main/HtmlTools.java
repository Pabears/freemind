/*FreeMind - A Program for creating and viewing Mindmaps
 *Copyright (C) 2006  Christian Foltin <christianfoltin@users.sourceforge.net>
 *See COPYING for Details
 *
 *This program is free software; you can redistribute it and/or
 *modify it under the terms of the GNU General Public License
 *as published by the Free Software Foundation; either version 2
 *of the License, or (at your option) any later version.
 *
 *This program is distributed in the hope that it will be useful,
 *but WITHOUT ANY WARRANTY; without even the implied warranty of
 *MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *GNU General Public License for more details.
 *
 *You should have received a copy of the GNU General Public License
 *along with this program; if not, write to the Free Software
 *Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
/*$Id: HtmlTools.java,v 1.1.2.7.2.1 2006-08-27 20:49:00 dpolivaev Exp $*/

package freemind.main;

import java.io.IOException;
import java.io.StringReader;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Locale;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.swing.text.BadLocationException;
import javax.xml.parsers.SAXParserFactory;

import org.xml.sax.InputSource;
import org.xml.sax.SAXParseException;
import org.xml.sax.helpers.DefaultHandler;

/** */
public class HtmlTools {

    private static final String FIND_TAGS_PATTERN = "<[^<>]+>";

    private static Logger logger;

    private static HtmlTools sInstance = new HtmlTools();

    
    /**
     * 
     */
    private HtmlTools() {
        super();
        logger = Resources.getInstance().getLogger(HtmlTools.class.getName());
    }

    public static HtmlTools getInstance() {
        return sInstance;
    }

    public String toXhtml(String htmlText) {
        StringReader reader = new StringReader(htmlText);
        StringWriter writer = new StringWriter();
        try {
            XHTMLWriter.html2xhtml(reader, writer);
            String resultXml = writer.toString();
            // for safety:
            if(!isWellformedXml(resultXml)) {
                return toXMLEscapedText(htmlText);
            }
            return resultXml;
        } catch (IOException e) {
            freemind.main.Resources.getInstance().logExecption(e);
        } catch (BadLocationException e) {
            freemind.main.Resources.getInstance().logExecption(e);
        }
        // fallback:
        htmlText = htmlText.replaceAll("<", "&gt;");
        htmlText = htmlText.replaceAll(">", "&lt;");
        return htmlText;
    }

    public String toHtml(String xhtmlText) {
        // Remove '/' from <.../> of elements that do not have '/' there in HTML
        return xhtmlText.replaceAll("<(("+
                    "br|area|base|basefont|"+
                    "bgsound|button|col|colgroup|embed|hr"+
                    "|img|input|isindex|keygen|link|meta"+
                    "|object|plaintext|spacer|wbr"+
                    ")(\\s[^>]*)?)/>",
                    "<$1>");
    }

    public static class IndexPair {
        public int originalStart;
        public int originalEnd;
        public int replacedStart;
        public int replacedEnd;
        /**
         */
        public IndexPair(int pOriginalStart, int pOriginalEnd, int pReplacedStart, int pReplacedEnd)
        {
            super();
            
            originalStart = pOriginalStart;
            originalEnd = pOriginalEnd;
            replacedStart = pReplacedStart;
            replacedEnd = pReplacedEnd;
        }
        /**
         * generated by CodeSugar http://sourceforge.net/projects/codesugar */
        
        public String toString() {
            StringBuffer buffer = new StringBuffer();
            buffer.append("[IndexPair:");
            buffer.append(" originalStart: ");
            buffer.append(originalStart);
            buffer.append(" originalEnd: ");
            buffer.append(originalEnd);
            buffer.append(" replacedStart: ");
            buffer.append(replacedStart);
            buffer.append(" replacedEnd: ");
            buffer.append(replacedEnd);
            buffer.append("]");
            return buffer.toString();
        }
    }
    
    /** Replaces text in node content without replacing tags.
     */
    public String getReplaceResult(Pattern pattern, String replacement, String text) {
        String input = text;
        ArrayList l = new ArrayList();
        StringBuffer sb = new StringBuffer();
        // remove tags and denote their positions:
        {
            Pattern p = Pattern.compile(FIND_TAGS_PATTERN);
            Matcher matcher = p.matcher(input);
            int lastMatchEnd = 0;
            while (matcher.find())
            {
                int replStart = sb.length();
                matcher.appendReplacement(sb, "");
                IndexPair indexPair = new IndexPair(lastMatchEnd, matcher.end(),
                        replStart, sb.length());
                lastMatchEnd = matcher.end();
                System.out.println(sb.toString() + ", " + input.substring(indexPair.originalStart, indexPair.originalEnd)+ ", " + indexPair);
                l.add(indexPair);
            }
            int replStart = sb.length();
            matcher.appendTail(sb);
            IndexPair indexPair = new IndexPair(lastMatchEnd, input.length(),
                    replStart, sb.length());
            System.out.println(sb.toString() + ", " + indexPair);
            l.add(indexPair);
            System.out.println(sb.toString());
        }
        
        String replaceBy = replacement;
        
        Pattern p = pattern;
        String replacedString = sb.toString();
        Matcher m = p.matcher(replacedString);
        StringBuffer sb2 = new StringBuffer();
        StringBuffer sbResult = new StringBuffer();
        if(m.find()) {
            m.appendReplacement(sb2, replaceBy);
            /* now, take all from 0 to m.start() from original.
             * append the replaced text, append all removed tags from the original
             * that stays in between and append the rest.
             */
            int mStart = m.start();
            int mEnd = m.end();
            
            //take all from 0 to m.start() from original.
            append(sbResult, input, l, 0, mStart);
            //append the replaced text
            sbResult.append(sb2.toString());
            //append all removed tags from the original that stays in between
            StringBuffer sbTemp = new StringBuffer();
            append(sbTemp, input, l, mStart+1, mEnd);
            sbResult.append(sbTemp.toString().replaceAll(".*?("+FIND_TAGS_PATTERN+")", "$1"));
            //append the rest.
            append(sbResult, input, l, mEnd, replacedString.length());
        } else {
            // no change:
            sbResult.append(input);
        }
//        m.appendTail(sb2);
        String result = sbResult.toString();
        System.out.println("Result:'"+result+"'");
        return result;
    }
    
    
    private void append(StringBuffer pResult, String pInput, ArrayList pListOfIndices, int pReducedStart, int pReducedEnd)
    {
        if(pReducedStart == pReducedEnd) {
            int minj = getMinimalOriginalPosition(pReducedStart, pListOfIndices);
            int maxj = getMaximalOriginalPosition(pReducedStart, pListOfIndices);
            pResult.append(pInput.substring(minj, maxj));
            return;
        }
        for(int i = pReducedStart; i < pReducedEnd; ++i) {
            int minj = getMinimalOriginalPosition(i, pListOfIndices);
            int maxj = getMaximalOriginalPosition(i, pListOfIndices);
            pResult.append(pInput.substring(minj, maxj));
        }
//        pResult.append(getChunk(pInput, pReducedEnd, pListOfIndices));
    }


//    private String getChunk(String pInput, int pPosition, ArrayList pListOfIndices)
//    {
//        StringBuffer sbTemp = new StringBuffer();
//        for (Iterator iter = pListOfIndices.iterator(); iter.hasNext();)
//        {
//            IndexPair pair = (IndexPair) iter.next();
//            if(pPosition == pair.replacedStart && pPosition == pair.replacedEnd) {
//                sbTemp.append(pInput.subSequence(pair.originalStart, pair.originalEnd));
//            }
//        }
//        return sbTemp.toString();
//    }
//

    public int getMinimalOriginalPosition(int pI, ArrayList pListOfIndices)
    {
        for (Iterator iter = pListOfIndices.iterator(); iter.hasNext();)
        {
            IndexPair pair = (IndexPair) iter.next();
            if(pI >= pair.replacedStart && pI <= pair.replacedEnd) {
                return pair.originalStart + pI - pair.replacedStart;
            }
        }
        throw new IllegalArgumentException("Position "+pI+" not found.");
    }
    /**
     * @return the maximal index i such that pI is mapped to i by removing all tags from the original input. 
     */
    public int getMaximalOriginalPosition(int pI, ArrayList pListOfIndices)
    {
        for(int i = pListOfIndices.size() -1 ; i >= 0; --i) {
            IndexPair pair = (IndexPair) pListOfIndices.get(i);
            if(pI >= pair.replacedStart) {
                return pair.originalStart + pI - pair.replacedStart;
            }
        }
        throw new IllegalArgumentException("Position "+pI+" not found.");
    }

    /**
     */
    public static boolean isHtmlNode(String text) {
        return text.toLowerCase(Locale.ENGLISH).matches("(?s)^\\s*<\\s*html.*?>.*");
    }

    public static String unicodeToHTMLUnicodeEntity(String text) {
       StringBuffer result = new StringBuffer((int)(text.length()*1.2)); // Heuristic reserve for expansion: factor 1.2
       int intValue;
       char myChar;
       for (int i = 0; i < text.length(); ++i) {
          myChar = text.charAt(i);
          intValue = (int) text.charAt(i);
          if (intValue > 128) {
             result.append("&#").append(intValue).append(';'); }
          else {
             result.append(myChar); }}
       return result.toString(); }

    public static String unescapeHTMLUnicodeEntity(String text) {
       StringBuffer result = new StringBuffer(text.length());
       StringBuffer entity = new StringBuffer();
       boolean readingEntity = false;
       char myChar;
       for (int i = 0; i < text.length(); ++i) {
          myChar = text.charAt(i);
          if (readingEntity) {
             if (myChar == ';') {
                if (entity.charAt(0) == '#') {
                   try {
                      if (entity.charAt(1) == 'x') {
                         result.append((char) Integer.parseInt(entity.substring(2), 16)); }
                      else {
                         result.append((char) Integer.parseInt(entity.substring(1), 10)); }}
                   catch (NumberFormatException e) {
                      result.append('&').append(entity).append(';'); }}
                else {
                   result.append('&').append(entity).append(';'); }
                entity.setLength(0);
                readingEntity = false; }
             else {
                entity.append(myChar); }}
          else {
             if (myChar == '&') {
                readingEntity = true; }
             else {
                result.append(myChar); }}}
       if (entity.length() > 0) {
          result.append('&').append(entity); }
       return result.toString(); }

    /** Removes all tags (<..>) from a string if it starts with "<html>..." to make it compareable.
     */
    public static String removeHtmlTagsFromString(String text) {
        if (HtmlTools.isHtmlNode(text)) {
            return text.replaceAll("(?s)<[^><]*>", ""); // (?s) enables that . matches newline.
        } else {
            return text;
        }
    }

    public static String htmlToPlain(String text) {
       // 0. remove all newlines
       // 1. replace newlines, paragraphs, and table rows
       // 2. remove XML tags
       // 3. replace HTML entities including &nbsp;
       // 4. unescape unicode entities
       // This is a very basic conversion, fixing the most annoying
       // inconvenience.  You can imagine much better conversion of
       // HTML to plain text. Most of HTML tags can be handled
       // sensibly, like web browsers do it.
       if (!isHtmlNode(text)) {
          return text; }
       //System.err.println("base:"+text);
       String intermediate = text.
          replaceAll("(?ims)[\n\t]","").        // Remove newlines
          replaceAll("(?ims) +"," ").           // Condense spaces
          replaceAll("(?ims)<br.*?>","\n").
          replaceAll("(?ims)<p.*?>","\n\n").    // Paragraph
          replaceAll("(?ims)<div.*?>","\n").  // Div - block
          replaceAll("(?ims)<tr.*?>","\n").
          replaceAll("(?ims)<dt.*?>","\n").     // Defined term
          replaceAll("(?ims)<dd.*?>","\n   ").  // Definition of defined term
          replaceAll("(?ims)<td.*?>"," ").
          replaceAll("(?ims)<[uo]l.*?>","\n").  // Beginning of a list
          replaceAll("(?ims)<li.*?>","\n   * ").
          replaceAll("(?ims) *</[^>]*>","").    // Remaining closing HTML tags
          replaceAll("(?ims)<[^/][^>]*> *",""). // Remaining opening HTML tags
          replaceAll("(?ims)&lt;", "<").replaceAll("(?ims)&gt;", ">").
          replaceAll("(?ims)&quot;", "\"").replaceAll("(?ims)&amp;", "&").
          replaceAll("(?ims)&nbsp;", " ");
       //System.err.println("intermediate:"+intermediate);
       return HtmlTools.unescapeHTMLUnicodeEntity(intermediate); }

    public static String plainToHTML(String text) {
       char myChar;
       String textTabsExpanded = text.replaceAll("\t","         "); // Use eight spaces as tab width.
       StringBuffer result = new StringBuffer(textTabsExpanded.length()); // Heuristic
       int lengthMinus1 = textTabsExpanded.length() - 1;
       result.append("<html><body><p>");
       for (int i = 0; i < textTabsExpanded.length(); ++i) {
          myChar = textTabsExpanded.charAt(i);
          switch (myChar) {
          case '&': result.append("&amp;"); break;
          case '<': result.append("&lt;"); break;
          case '>': result.append("&gt;"); break;
          case ' ':
             if ( i > 0 && i < lengthMinus1 &&
                  (int)textTabsExpanded.charAt(i-1) > 32 && (int)textTabsExpanded.charAt(i+1) > 32 ) {
                result.append(' '); }
             else {
                result.append("&nbsp;"); }
             break;
          case '\n': result.append("<br>"); break;
          default:  result.append(myChar); }}
       return result.toString(); }

    
    public static String toXMLUnescapedText(String text) {
        return text.replaceAll("&lt;", "<").replaceAll("&gt;", ">").replaceAll(
                "&quot;", "\"").replaceAll("&amp;", "&");
    }

    public static String toXMLEscapedTextExpandingWhitespace(String text) {
        // Spaces and tabs are handled
        text = text.replaceAll("\t","         "); // Use eight spaces as tab width.
        int len = text.length();
        StringBuffer result = new StringBuffer(len);
        char myChar;
        for (int i = 0; i < len; ++i) {
            myChar = text.charAt(i);
            switch (myChar) {
            case '&': result.append("&amp;"); break;
            case '<': result.append("&lt;"); break;
            case '>': result.append("&gt;"); break;
            case ' ':
               if ( i > 0 && i < len-1 &&
                    (int)text.charAt(i-1) > 32 && (int)text.charAt(i+1) > 32 ) {
                  result.append(' '); }
               else {
                  result.append("&nbsp;"); }
               break;
            default:
                result.append(myChar);
            }
        }
        return result.toString();
    }

    public static String toXMLEscapedText(String text) {
        return text.replaceAll("&", "&amp;").replaceAll("<", "&lt;")
                .replaceAll(">", "&gt;").replaceAll("\"", "&quot;");
    }

    /**
     * @return true, if well formed XML.
     */
    public boolean isWellformedXml(String xml) {
        try {
            // Create a builder factory
            SAXParserFactory factory = SAXParserFactory.newInstance();
            factory.setValidating(false);

            // Create the builder and parse the file
            factory.newSAXParser().parse(new InputSource(new StringReader(xml)), new DefaultHandler());
            return true;
        } catch (SAXParseException e) {
            logger.log(Level.SEVERE, "XmlParseError on line " + e.getLineNumber() + " of " + xml, e);
        } catch (Exception e) {
            logger.log(Level.SEVERE, "XmlParseError", e);
        }
        return false;
    }
    

}
